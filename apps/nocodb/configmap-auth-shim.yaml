# yamllint disable rule:line-length
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nocodb-auth-shim
  namespace: nocodb
data:
  server.js: |
    const http = require('http');
    const https = require('https');
    const url = require('url');

    const PORT = process.env.PORT || 3000;
    const NOCODB_URL = process.env.NOCODB_URL || 'http://localhost:8080';
    const SESSION_TTL = parseInt(process.env.SESSION_TTL_SECONDS || '604800', 10) * 1000;

    const sessionStore = new Map();

    function getUserMapping() {
      const mapping = process.env.USER_MAPPING || '{}';
      try {
        return JSON.parse(mapping);
      } catch (err) {
        console.error('Failed to parse USER_MAPPING:', err.message);
        return {};
      }
    }

    function loginToNocoDB(email, password) {
      return new Promise((resolve, reject) => {
        const data = JSON.stringify({ email, password });
        const parsedUrl = url.parse(NOCODB_URL);

        const options = {
          hostname: parsedUrl.hostname,
          port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
          path: '/api/v1/auth/user/signin',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': data.length
          }
        };

        const httpModule = parsedUrl.protocol === 'https:' ? https : http;
        const req = httpModule.request(options, (res) => {
          let body = '';
          res.on('data', (chunk) => body += chunk);
          res.on('end', () => {
            if (res.statusCode === 200) {
              try {
                const parsed = JSON.parse(body);
                if (parsed.token) {
                  resolve({ success: true, token: parsed.token });
                } else {
                  resolve({ success: false, error: 'No token in response' });
                }
              } catch (err) {
                resolve({ success: false, error: 'Invalid JSON response' });
              }
            } else {
              resolve({ success: false, error: `HTTP ${res.statusCode}` });
            }
          });
        });

        req.on('error', (err) => resolve({ success: false, error: err.message }));
        req.write(data);
        req.end();
      });
    }

    function parseCookies(cookieHeader) {
      const cookies = {};
      if (!cookieHeader) return cookies;

      cookieHeader.split(';').forEach(cookie => {
        const parts = cookie.trim().split('=');
        if (parts.length === 2) {
          cookies[parts[0]] = parts[1];
        }
      });
      return cookies;
    }

    function proxyToNocoDB(req, res, token) {
      const parsedUrl = url.parse(NOCODB_URL);
      const targetUrl = url.parse(req.url);

      const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
        path: targetUrl.path,
        method: req.method,
        headers: {
          ...req.headers,
          'xc-auth': token,
          host: parsedUrl.hostname
        }
      };

      // Remove headers that shouldn't be forwarded
      delete options.headers['cookie'];
      delete options.headers['nc-session'];

      const httpModule = parsedUrl.protocol === 'https:' ? https : http;
      const proxy = httpModule.request(options, (proxyRes) => {
        // Remove Set-Cookie from NocoDB (we manage sessions)
        const headers = { ...proxyRes.headers };
        delete headers['set-cookie'];

        res.writeHead(proxyRes.statusCode, headers);
        proxyRes.pipe(res);
      });

      proxy.on('error', (err) => {
        console.error('Proxy error:', err.message);
        res.writeHead(502, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Bad Gateway', message: err.message }));
      });

      req.pipe(proxy);
    }

    async function handleRequest(req, res) {
      if (req.url === '/healthz') {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        return res.end('OK');
      }

      const userEmail = req.headers['x-auth-request-email'] || req.headers['x-forwarded-email'];
      console.log(`Request: ${req.method} ${req.url} from ${userEmail || 'anonymous'}`);

      if (!userEmail) {
        res.writeHead(401, { 'Content-Type': 'application/json' });
        return res.end(JSON.stringify({
          error: 'Unauthorized',
          message: 'No authenticated user from oauth2-proxy'
        }));
      }

      const cookies = parseCookies(req.headers.cookie);
      const sessionId = cookies['nc-session'];
      const cachedSession = sessionStore.get(sessionId);

      if (cachedSession && cachedSession.email === userEmail && cachedSession.expires > Date.now()) {
        return proxyToNocoDB(req, res, cachedSession.token);
      }

      const userMapping = getUserMapping();
      const credentials = userMapping[userEmail];

      if (!credentials) {
        console.error(`No credentials for user: ${userEmail}`);
        res.writeHead(403, { 'Content-Type': 'application/json' });
        return res.end(JSON.stringify({
          error: 'Forbidden',
          message: 'No NocoDB credentials configured for your account'
        }));
      }

      const loginResult = await loginToNocoDB(credentials.email, credentials.password);

      if (!loginResult.success) {
        console.error(`Login failed for ${userEmail}:`, loginResult.error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        return res.end(JSON.stringify({
          error: 'Authentication failed',
          message: 'Failed to login to NocoDB'
        }));
      }

      const newSessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      sessionStore.set(newSessionId, {
        email: userEmail,
        token: loginResult.token,
        expires: Date.now() + SESSION_TTL
      });

      res.setHeader('Set-Cookie', `nc-session=${newSessionId}; HttpOnly; Secure; SameSite=Lax; Max-Age=${SESSION_TTL / 1000}; Path=/`);
      proxyToNocoDB(req, res, loginResult.token);
    }

    setInterval(() => {
      const now = Date.now();
      let cleaned = 0;
      for (const [sessionId, session] of sessionStore.entries()) {
        if (session.expires < now) {
          sessionStore.delete(sessionId);
          cleaned++;
        }
      }
      if (cleaned > 0) {
        console.log(`Cleaned ${cleaned} expired sessions. Active: ${sessionStore.size}`);
      }
    }, 60 * 60 * 1000);

    const server = http.createServer(handleRequest);
    server.listen(PORT, () => {
      console.log(`NocoDB Auth Shim running on port ${PORT}`);
      console.log(`Proxying to: ${NOCODB_URL}`);
      console.log(`Session TTL: ${SESSION_TTL / 1000}s`);
    });
